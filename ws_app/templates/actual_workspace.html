<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>{{ workspace.name }}</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.min.js"></script>
  </head>
  <body>
    <div id="toolbar" class="toolbar">
      <div class="toolbar-left">
        <button type="button" id="bold-btn" class="toolbar-btn">B</button>
        <button type="button" id="italic-btn" class="toolbar-btn">I</button>
        <button type="button" id="underline-btn" class="toolbar-btn">U</button>
        <select class="toolbar-option" id="font-selector">
          <option value="Arial" selected>Arial</option>
          <option value="Verdana">Verdana</option>
          <option value="Times New Roman">Times New Roman</option>
          <option value="Courier New">Courier New</option>
          <option value="Georgia">Georgia</option>
          <option value="Comic Sans MS">Comic Sans MS</option>
          <option value="Trebuchet MS">Trebuchet MS</option>
        </select>
        <select class="toolbar-option" id="font-size">
          <option value="6px">6px</option>
          <option value="8px">8px</option>
          <option value="10px">10px</option>
          <option value="12px">12px</option>
          <option value="14px">14px</option>
          <option value="16px" selected>16px</option>
          <option value="18px">18px</option>
          <option value="20px">20px</option>
          <option value="22px">22px</option>
          <option value="24px">24px</option>
          <option value="26px">26px</option>
          <option value="28px">28px</option>
          <option value="30px">30px</option>
          <option value="32px">32px</option>
          <option value="34px">34px</option>
          <option value="36px">36px</option>
          <option value="38px">38px</option>
          <option value="40px">40px</option>
        </select>
        <input type="color" class="toolbar-option" id="font-color" value="#000000" />
        <input type="color" class="toolbar-option" id="bg-color" value="#ffffff" />
        <input type="range" class="toolbar-option" id="text-opacity" min="0" max="100" value="100" />
      </div>
      <div class="toolbar-middle">
        <button type="button" id="marker-toggle" class="toolbar-btn">Marker</button>
        <input type="range" class="toolbar-option" id="marker-thickness" min="1" max="20" value="5" />
        <input type="color" class="toolbar-option" id="marker-color" value="#ff0000" />
        <input type="range" class="toolbar-option" id="marker-opacity" min="0" max="100" value="100" />
        <button type="button" id="eraser-toggle" class="toolbar-btn">Eraser</button>
        <input type="range" class="toolbar-option" id="eraser-thickness" min="5" max="50" value="10" />
      </div>
      <div class="toolbar-right">
        <button type="button" id="upload-btn" class="toolbar-btn">Upload Image or PDF</button>
        <input type="file" id="file-upload" accept="image/*,application/pdf" hidden />
        <button type="button" id="save-btn" class="toolbar-btn">Save and return to dashboard</button>
      </div>
    </div>
    <div id="workspace" class="workspace-container">
      <h1 class="workspace-title">{{ workspace.name }}</h1>
      <div id="canvas" class="workspace-canvas">
        <canvas id="drawing-layer"></canvas>
      </div>
    </div>
    <div id="eraser-cursor"></div>
    <script>
      let imageZ = 1,
          textZ = 1000,
          currentTextEntity = null,
          selectedImage = null,
          currentTool = "select",
          drawing = false,
          scale = 1,
          globalDragOccurred = false,
          resizingActive = false,
          resized = false,
          cachedRect = null,
          lastDrawTime = 0;
      const defaultTextSettings = {
        fontFamily: "Arial",
        fontSize: "16px",
        fontWeight: "normal",
        fontStyle: "normal",
        textDecoration: "none",
        color: "#000000",
        backgroundColor: "#ffffff",
        backgroundOpacity: 1
      };
      const workspace = document.getElementById("workspace"),
            canvas = document.getElementById("canvas"),
            drawingLayer = document.getElementById("drawing-layer"),
            eraserCursor = document.getElementById("eraser-cursor"),
            boldBtn = document.getElementById("bold-btn"),
            italicBtn = document.getElementById("italic-btn"),
            underlineBtn = document.getElementById("underline-btn"),
            toolbarFontSelector = document.getElementById("font-selector"),
            toolbarFontSize = document.getElementById("font-size"),
            toolbarFontColor = document.getElementById("font-color"),
            toolbarBgColor = document.getElementById("bg-color"),
            toolbarTextOpacity = document.getElementById("text-opacity"),
            markerToggle = document.getElementById("marker-toggle"),
            markerThicknessInput = document.getElementById("marker-thickness"),
            markerColorInput = document.getElementById("marker-color"),
            markerOpacityInput = document.getElementById("marker-opacity"),
            eraserToggle = document.getElementById("eraser-toggle"),
            eraserThicknessInput = document.getElementById("eraser-thickness"),
            uploadBtn = document.getElementById("upload-btn"),
            fileUpload = document.getElementById("file-upload");
      drawingLayer.width = canvas.clientWidth;
      drawingLayer.height = canvas.clientHeight;
      drawingLayer.style.position = "absolute";
      drawingLayer.style.top = "0";
      drawingLayer.style.left = "0";
      drawingLayer.style.zIndex = "10000";
      drawingLayer.style.pointerEvents = "none";
      const workerCanvas = drawingLayer.transferControlToOffscreen();
      const worker = new Worker("{{ url_for('static', filename='drawing-worker.js') }}");
      worker.postMessage({ canvas: workerCanvas, width: drawingLayer.width, height: drawingLayer.height }, [workerCanvas]);
      function sendDrawingEvent(type, data) {
        worker.postMessage({ type, data });
      }
      uploadBtn.addEventListener("click", () => { fileUpload.click(); });
      fileUpload.addEventListener("change", (event) => {
        const file = event.target.files[0];
        if (file) {
          if (file.type.startsWith("application/pdf")) {
            handlePdfUpload(file, (workspace.scrollLeft + workspace.clientWidth / 2) / scale, (workspace.scrollTop + workspace.clientHeight / 2) / scale);
          } else {
            const centerX = (workspace.scrollLeft + workspace.clientWidth / 2) / scale;
            const centerY = (workspace.scrollTop + workspace.clientHeight / 2) / scale;
            handleFileUpload(file, centerX, centerY);
          }
          fileUpload.value = "";
        }
      });
      workspace.addEventListener("wheel", (e) => {
        if (e.ctrlKey) {
          e.preventDefault();
          let delta = -e.deltaY * 0.001;
          let newScale = Math.min(Math.max(scale + delta, 0.5), 3);
          let rect = workspace.getBoundingClientRect();
          let pointerX = e.clientX - rect.left;
          let pointerY = e.clientY - rect.top;
          let pointerCanvasX = workspace.scrollLeft + pointerX;
          let pointerCanvasY = workspace.scrollTop + pointerY;
          let newScrollLeft = pointerCanvasX * (newScale / scale) - pointerX;
          let newScrollTop = pointerCanvasY * (newScale / scale) - pointerY;
          canvas.style.transformOrigin = "0 0";
          canvas.style.transform = "scale(" + newScale + ")";
          scale = newScale;
          workspace.scrollLeft = newScrollLeft;
          workspace.scrollTop = newScrollTop;
        }
      }, { passive: false });
      workspace.addEventListener("scroll", () => {
        let maxScrollLeft = canvas.offsetWidth * scale - workspace.clientWidth;
        let maxScrollTop = canvas.offsetHeight * scale - workspace.clientHeight;
        if (workspace.scrollLeft < 0) workspace.scrollLeft = 0;
        if (workspace.scrollTop < 0) workspace.scrollTop = 0;
        if (workspace.scrollLeft > maxScrollLeft) workspace.scrollLeft = maxScrollLeft;
        if (workspace.scrollTop > maxScrollTop) workspace.scrollTop = maxScrollTop;
      });
      document.getElementById("toolbar").addEventListener("mousedown", (e) => { e.stopPropagation(); });
      canvas.addEventListener("dragover", (e) => { e.preventDefault(); });
      canvas.addEventListener("drop", (e) => {
        e.preventDefault();
        let rect = canvas.getBoundingClientRect();
        let dropX = (e.clientX - rect.left + canvas.scrollLeft) / scale;
        let dropY = (e.clientY - rect.top + canvas.scrollTop) / scale;
        const file = e.dataTransfer.files[0];
        if (file) { handleFileUpload(file, dropX, dropY); }
        else { createTextElement(dropX, dropY); }
      });
      canvas.addEventListener("click", (e) => {
        if (resized) { resized = false; return; }
        if (resizingActive) return;
        if (e.target.closest(".text-entity")) return;
        if (currentTool === "marker" || currentTool === "eraser") return;
        if (globalDragOccurred) { globalDragOccurred = false; return; }
        let rect = canvas.getBoundingClientRect();
        let clickX = (e.clientX - rect.left + canvas.scrollLeft) / scale;
        let clickY = (e.clientY - rect.top + canvas.scrollTop) / scale;
        if (currentTextEntity && currentTextEntity.textContent.trim() === "") {
          currentTextEntity.remove();
          currentTextEntity = null;
        } else { createTextElement(clickX, clickY); }
      });
      document.addEventListener("keydown", (e) => {
        if (e.key === "Delete" && selectedImage) { selectedImage.remove(); selectedImage = null; }
      });
      function handleFileUpload(file, x, y) {
        if (file.type.startsWith("application/pdf")) return;
        const reader = new FileReader();
        reader.onload = (event) => {
          if (file.type.startsWith("image/")) { createImageElement(event.target.result, x, y); }
        };
        reader.readAsDataURL(file);
      }
      async function handlePdfUpload(file, x, y) {
        const arrayBuffer = await file.arrayBuffer();
        const pdf = await pdfjsLib.getDocument(new Uint8Array(arrayBuffer)).promise;
        let currentY = y;
        for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
          const page = await pdf.getPage(pageNum);
          const viewport = page.getViewport({ scale: 1 });
          const canvasTemp = document.createElement("canvas");
          const ctxTemp = canvasTemp.getContext("2d");
          canvasTemp.width = viewport.width;
          canvasTemp.height = viewport.height;
          await page.render({ canvasContext: ctxTemp, viewport: viewport }).promise;
          let centerX = (workspace.scrollLeft + workspace.clientWidth / 2) / scale - viewport.width / 2;
          createImageElement(canvasTemp.toDataURL(), centerX, currentY);
          currentY += viewport.height + 5;
        }
      }
      function createImageElement(src, x, y) {
        const wrapper = document.createElement("div");
        wrapper.classList.add("image-wrapper");
        wrapper.style.left = x + "px";
        wrapper.style.top = y + "px";
        wrapper.style.zIndex = imageZ++;
        const img = document.createElement("img");
        img.src = src;
        img.classList.add("workspace-image");
        img.style.width = "200px";
        img.style.height = "auto";
        img.setAttribute("draggable", "false");
        wrapper.appendChild(img);
        canvas.appendChild(wrapper);
        makeElementDraggable(wrapper);
        addResizeHandles(wrapper, img);
        wrapper.addEventListener("click", () => { selectedImage = wrapper; });
      }
      function addResizeHandles(wrapper, img) {
        ["top-left", "top-right", "bottom-left", "bottom-right"].forEach((pos) => {
          const handle = document.createElement("div");
          handle.classList.add("resize-handle", pos);
          wrapper.appendChild(handle);
          makeElementResizable(wrapper, img, handle, pos);
        });
      }
      function makeElementResizable(wrapper, img, handle, position) {
        handle.addEventListener("mousedown", (e) => {
          e.stopPropagation();
          resizingActive = true;
          let startX = e.clientX, startY = e.clientY, startWidth = img.offsetWidth, startHeight = img.offsetHeight, startLeft = wrapper.offsetLeft, startTop = wrapper.offsetTop;
          function onMouseMove(e) {
            let deltaX = e.clientX - startX, deltaY = e.clientY - startY;
            if (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5) { resized = true; }
            if (position.includes("right")) { img.style.width = Math.max(50, startWidth + deltaX) + "px"; }
            if (position.includes("left")) {
              img.style.width = Math.max(50, startWidth - deltaX) + "px";
              wrapper.style.left = Math.max(0, startLeft + deltaX) + "px";
            }
            if (position.includes("bottom")) { img.style.height = Math.max(50, startHeight + deltaY) + "px"; }
            if (position.includes("top")) {
              img.style.height = Math.max(50, startHeight - deltaY) + "px";
              wrapper.style.top = Math.max(0, startTop + deltaY) + "px";
            }
          }
          function onMouseUp() {
            document.removeEventListener("mousemove", onMouseMove);
            document.removeEventListener("mouseup", onMouseUp);
            resizingActive = false;
          }
          document.addEventListener("mousemove", onMouseMove);
          document.addEventListener("mouseup", onMouseUp);
        });
      }
      function createTextElement(x, y, content = "") {
        const textEl = document.createElement("div");
        textEl.classList.add("text-entity");
        textEl.style.left = x + "px";
        textEl.style.top = y + "px";
        textEl.style.zIndex = textZ++;
        textEl.style.opacity = "1";
        textEl.textContent = content;
        textEl.setAttribute("contenteditable", "true");
        textEl.style.fontFamily = defaultTextSettings.fontFamily;
        textEl.style.fontSize = defaultTextSettings.fontSize;
        textEl.style.fontWeight = defaultTextSettings.fontWeight;
        textEl.style.fontStyle = defaultTextSettings.fontStyle;
        textEl.style.textDecoration = defaultTextSettings.textDecoration;
        textEl.style.color = defaultTextSettings.color;
        textEl.style.backgroundColor = hexToRgba(defaultTextSettings.backgroundColor, defaultTextSettings.backgroundOpacity);
        textEl.addEventListener("focus", () => {
          currentTextEntity = textEl;
          if (!textEl.dataset.custom) {
            toolbarFontSelector.value = defaultTextSettings.fontFamily;
            toolbarFontSize.value = defaultTextSettings.fontSize;
            toolbarFontColor.value = defaultTextSettings.color;
            toolbarBgColor.value = defaultTextSettings.backgroundColor;
            toolbarTextOpacity.value = defaultTextSettings.backgroundOpacity * 100;
          } else {
            const comp = window.getComputedStyle(textEl);
            toolbarFontSelector.value = comp.fontFamily.replace(/["']/g, "");
            toolbarFontSize.value = comp.fontSize;
            toolbarFontColor.value = rgbToHex(comp.color);
            toolbarBgColor.value = rgbToHex(comp.backgroundColor);
            toolbarTextOpacity.value = Math.round(parseFloat(comp.opacity) * 100);
          }
        });
        textEl.addEventListener("blur", () => {
          if (textEl.textContent.trim() === "") { textEl.remove(); }
        });
        makeElementDraggable(textEl);
        canvas.appendChild(textEl);
        textEl.focus();
      }
      function rgbToHex(rgb) {
        const result = /^rgba?\((\d+),\s*(\d+),\s*(\d+)/i.exec(rgb);
        return result ? "#" + ((1 << 24) + (parseInt(result[1]) << 16) + (parseInt(result[2]) << 8) + parseInt(result[3])).toString(16).slice(1) : rgb;
      }
      function hexToRgba(hex, alpha) {
        hex = hex.replace("#", "");
        if (hex.length === 3) { hex = hex.split("").map((c) => c + c).join(""); }
        const r = parseInt(hex.substring(0, 2), 16);
        const g = parseInt(hex.substring(2, 4), 16);
        const b = parseInt(hex.substring(4, 6), 16);
        return `rgba(${r},${g},${b},${alpha})`;
      }
      function makeElementDraggable(el) {
        el.setAttribute("draggable", "false");
        el.addEventListener("dragstart", (e) => { e.preventDefault(); });
        el.addEventListener("mousedown", (e) => {
          if (e.target.closest("#toolbar")) return;
          e.stopPropagation();
          if (el.classList.contains("text-entity")) {
            el.style.zIndex = textZ++;
            currentTextEntity = el;
          } else if (el.classList.contains("image-wrapper")) {
            el.style.zIndex = imageZ++;
            selectedImage = el;
          }
          let startX = e.clientX, startY = e.clientY;
          let rect = el.getBoundingClientRect();
          let canvasRect = canvas.getBoundingClientRect();
          let shiftX = e.clientX - rect.left, shiftY = e.clientY - rect.top;
          let moved = false;
          let ghost = el.cloneNode(true);
          ghost.style.position = "absolute";
          ghost.style.pointerEvents = "none";
          ghost.style.opacity = "0.7";
          ghost.style.left = el.style.left;
          ghost.style.top = el.style.top;
          ghost.style.cursor = "grabbing";
          canvas.appendChild(ghost);
          function moveAt(pageX, pageY) {
            let newX = (pageX - canvasRect.left - shiftX + canvas.scrollLeft) / scale;
            let newY = (pageY - canvasRect.top - shiftY + canvas.scrollTop) / scale;
            ghost.style.left = Math.max(0, newX) + "px";
            ghost.style.top = Math.max(0, newY) + "px";
          }
          function onMouseMove(e) {
            if (!moved) {
              let dist = Math.hypot(e.clientX - startX, e.clientY - startY);
              if (dist > 5) { moved = true; globalDragOccurred = true; }
            }
            moveAt(e.pageX, e.pageY);
          }
          document.addEventListener("mousemove", onMouseMove);
          document.addEventListener("mouseup", (e) => {
            document.removeEventListener("mousemove", onMouseMove);
            el.style.left = ghost.style.left;
            el.style.top = ghost.style.top;
            canvas.removeChild(ghost);
          }, { once: true });
        });
      }
      function setMarkerActive(active) {
        if (active) { workspace.classList.add("marker-active"); }
        else { workspace.classList.remove("marker-active"); }
      }
      markerToggle.addEventListener("click", function () {
        currentTool = currentTool === "marker" ? "select" : "marker";
        markerToggle.classList.toggle("active", currentTool === "marker");
        if (currentTool === "marker") {
          canvas.style.cursor = "crosshair";
          drawingLayer.style.pointerEvents = "auto";
          setMarkerActive(true);
        } else {
          canvas.style.cursor = "default";
          drawingLayer.style.pointerEvents = "none";
          setMarkerActive(false);
        }
      });
      eraserToggle.addEventListener("click", function () {
        currentTool = currentTool === "eraser" ? "select" : "eraser";
        eraserToggle.classList.toggle("active", currentTool === "eraser");
        if (currentTool === "eraser") {
          canvas.style.cursor = "none";
          drawingLayer.style.pointerEvents = "auto";
          setMarkerActive(true);
          eraserCursor.style.display = "block";
        } else {
          canvas.style.cursor = "default";
          drawingLayer.style.pointerEvents = "none";
          setMarkerActive(false);
          eraserCursor.style.display = "none";
        }
      });
      document.addEventListener("mousemove", (e) => {
        if (currentTool === "eraser") {
          updateEraserCursor(e);
          eraserCursor.style.display = "block";
        }
      });
      canvas.addEventListener("mouseleave", () => { eraserCursor.style.display = "none"; });
      canvas.addEventListener("mousedown", function (e) {
        if (e.target.closest("#toolbar")) return;
        if (currentTool === "marker" || currentTool === "eraser") {
          drawing = true;
          cachedRect = canvas.getBoundingClientRect();
          const x = (e.clientX - cachedRect.left) / scale;
          const y = (e.clientY - cachedRect.top) / scale;
          sendDrawingEvent("start", {
            x: x,
            y: y,
            tool: currentTool,
            lineWidth: currentTool === "eraser" ? eraserThicknessInput.value : markerThicknessInput.value,
            color: currentTool === "eraser" ? "rgba(0,0,0,1)" : markerColorInput.value,
            opacity: currentTool === "eraser" ? 1 : markerOpacityInput.value / 100
          });
        }
      });
      canvas.addEventListener("mousemove", (e) => {
        if (!drawing) return;
        const x = (e.clientX - cachedRect.left) / scale;
        const y = (e.clientY - cachedRect.top) / scale;
        const now = performance.now();
        if (now - lastDrawTime < 16) return;
        lastDrawTime = now;
        sendDrawingEvent("draw", { x: x, y: y });
      });
      document.addEventListener("mouseup", (e) => {
        if (drawing) {
          drawing = false;
          sendDrawingEvent("end", {});
        }
      });
      function sendDrawingEvent(type, data) {
        worker.postMessage({ type, data });
      }
      function rgbToHex(rgb) {
        const result = /^rgba?\((\d+),\s*(\d+),\s*(\d+)/i.exec(rgb);
        return result ? "#" + ((1 << 24) + (parseInt(result[1]) << 16) + (parseInt(result[2]) << 8) + parseInt(result[3])).toString(16).slice(1) : rgb;
      }
      function hexToRgba(hex, alpha) {
        hex = hex.replace("#", "");
        if (hex.length === 3) { hex = hex.split("").map((c) => c + c).join(""); }
        const r = parseInt(hex.substring(0, 2), 16);
        const g = parseInt(hex.substring(2, 4), 16);
        const b = parseInt(hex.substring(4, 6), 16);
        return `rgba(${r},${g},${b},${alpha})`;
      }
      function updateEraserCursor(e) {
        eraserCursor.style.width = eraserThicknessInput.value + "px";
        eraserCursor.style.height = eraserThicknessInput.value + "px";
        eraserCursor.style.left = e.clientX - eraserThicknessInput.value / 2 + "px";
        eraserCursor.style.top = e.clientY - eraserThicknessInput.value / 2 + "px";
      }
      document.getElementById("bold-btn").addEventListener("click", () => {
        if (currentTextEntity) {
          currentTextEntity.style.fontWeight = currentTextEntity.style.fontWeight === "bold" ? "normal" : "bold";
          defaultTextSettings.fontWeight = currentTextEntity.style.fontWeight;
          currentTextEntity.dataset.custom = "true";
        }
      });
      document.getElementById("italic-btn").addEventListener("click", () => {
        if (currentTextEntity) {
          currentTextEntity.style.fontStyle = currentTextEntity.style.fontStyle === "italic" ? "normal" : "italic";
          defaultTextSettings.fontStyle = currentTextEntity.style.fontStyle;
          currentTextEntity.dataset.custom = "true";
        }
      });
      document.getElementById("underline-btn").addEventListener("click", () => {
        if (currentTextEntity) {
          currentTextEntity.style.textDecoration = currentTextEntity.style.textDecoration === "underline" ? "none" : "underline";
          defaultTextSettings.textDecoration = currentTextEntity.style.textDecoration;
          currentTextEntity.dataset.custom = "true";
        }
      });
      toolbarFontSelector.addEventListener("change", function () {
        defaultTextSettings.fontFamily = this.value;
        if (currentTextEntity) {
          currentTextEntity.style.fontFamily = this.value;
          currentTextEntity.dataset.custom = "true";
        }
      });
      toolbarFontSize.addEventListener("change", function () {
        defaultTextSettings.fontSize = this.value;
        if (currentTextEntity) {
          currentTextEntity.style.fontSize = this.value;
          currentTextEntity.dataset.custom = "true";
        }
      });
      toolbarFontColor.addEventListener("change", function () {
        defaultTextSettings.color = this.value;
        if (currentTextEntity) {
          currentTextEntity.style.color = this.value;
          currentTextEntity.dataset.custom = "true";
        }
      });
      toolbarBgColor.addEventListener("change", function () {
        defaultTextSettings.backgroundColor = this.value;
        if (currentTextEntity) {
          currentTextEntity.style.backgroundColor = hexToRgba(this.value, defaultTextSettings.backgroundOpacity);
          currentTextEntity.dataset.custom = "true";
        }
      });
      toolbarTextOpacity.addEventListener("input", function () {
        defaultTextSettings.backgroundOpacity = this.value / 100;
        if (currentTextEntity) {
          currentTextEntity.style.backgroundColor = hexToRgba(toolbarBgColor.value, this.value / 100);
          currentTextEntity.dataset.custom = "true";
        }
      });
    </script>
  </body>
</html>
