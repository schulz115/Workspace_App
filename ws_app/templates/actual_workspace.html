<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>{{ workspace.name }}</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>
  <div id="toolbar" class="toolbar">
    <div class="toolbar-group">
      <select class="toolbar-option" id="font-selector">
        <option value="">Schriftart</option>
        <option value="Arial">Arial</option>
        <option value="Times New Roman">Times New Roman</option>
        <option value="Verdana">Verdana</option>
      </select>
      <select class="toolbar-option" id="font-size">
        <option value="">Schriftgröße</option>
        <option value="12px">12</option>
        <option value="14px">14</option>
        <option value="16px">16</option>
        <option value="18px">18</option>
        <option value="20px">20</option>
      </select>
      <input type="color" class="toolbar-option" id="font-color" value="#000000">
      <input type="color" class="toolbar-option" id="bg-color" value="#ffffff">
      <input type="range" class="toolbar-option" id="text-opacity" min="0" max="100" value="100">
    </div>
    <div class="toolbar-group">
      <button type="button" id="marker-toggle" class="toolbar-btn">Marker</button>
      <input type="range" class="toolbar-option" id="marker-thickness" min="1" max="20" value="5">
      <input type="color" class="toolbar-option" id="marker-color" value="#ff0000">
      <input type="range" class="toolbar-option" id="marker-opacity" min="0" max="100" value="100">
    </div>
    <div class="toolbar-group">
      <button type="button" id="eraser-toggle" class="toolbar-btn">Radiergummi</button>
      <input type="range" class="toolbar-option" id="eraser-thickness" min="5" max="50" value="10">
    </div>
    <div class="toolbar-group center-group">
      <button type="button" id="upload-btn" class="toolbar-btn">+<br>Upload Image or PDF</button>
      <input type="file" id="file-upload" accept="image/*,application/pdf" hidden>
    </div>
    <div class="toolbar-group right-group">
      <button type="button" id="save-btn" class="toolbar-btn">Save and return to dashboard</button>
    </div>
  </div>
  <div class="workspace-container" id="workspace">
    <h1 class="workspace-title">{{ workspace.name }}</h1>
    <div id="canvas" class="workspace-canvas">
      <canvas id="drawing-layer"></canvas>
    </div>
  </div>
  <script>
    let imageZ = 1;
    let textZ = 1000;
    let currentTextEntity = null;
    let currentTool = "select";
    let drawing = false;
    let lastX = 0;
    let lastY = 0;
    const canvas = document.getElementById("canvas");
    const drawingLayer = document.getElementById("drawing-layer");
    drawingLayer.width = canvas.clientWidth;
    drawingLayer.height = canvas.clientHeight;
    drawingLayer.style.position = "absolute";
    drawingLayer.style.top = "0";
    drawingLayer.style.left = "0";
    drawingLayer.style.zIndex = "-1";
    drawingLayer.style.pointerEvents = "none";
    const ctx = drawingLayer.getContext("2d");
    const toolbarFontSelector = document.getElementById("font-selector");
    const toolbarFontSize = document.getElementById("font-size");
    const toolbarFontColor = document.getElementById("font-color");
    const toolbarBgColor = document.getElementById("bg-color");
    const toolbarTextOpacity = document.getElementById("text-opacity");
    const markerToggle = document.getElementById("marker-toggle");
    const markerThicknessInput = document.getElementById("marker-thickness");
    const markerColorInput = document.getElementById("marker-color");
    const markerOpacityInput = document.getElementById("marker-opacity");
    const eraserToggle = document.getElementById("eraser-toggle");
    const eraserThicknessInput = document.getElementById("eraser-thickness");
    const uploadBtn = document.getElementById("upload-btn");
    const fileUpload = document.getElementById("file-upload");
    uploadBtn.addEventListener("click", function() {
      fileUpload.click();
    });
    fileUpload.addEventListener("change", function(event) {
      const file = event.target.files[0];
      if (file) { handleFileUpload(file, 100, 100); }
    });
    canvas.addEventListener("dragover", function(event) {
      event.preventDefault();
    });
    canvas.addEventListener("drop", function(event) {
      event.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const dropX = event.clientX - rect.left + canvas.scrollLeft;
      const dropY = event.clientY - rect.top + canvas.scrollTop;
      const file = event.dataTransfer.files[0];
      if (file) { handleFileUpload(file, dropX, dropY); }
      else { createTextElement(dropX, dropY); }
    });
    canvas.addEventListener("click", function(event) {
      if (event.target === canvas) {
        const rect = canvas.getBoundingClientRect();
        const clickX = event.clientX - rect.left + canvas.scrollLeft;
        const clickY = event.clientY - rect.top + canvas.scrollTop;
        createTextElement(clickX, clickY);
      }
    });
    function handleFileUpload(file, x, y) {
      const reader = new FileReader();
      reader.onload = function(event) {
        if (file.type.startsWith("image/")) { createImageElement(event.target.result, x, y); }
      };
      reader.readAsDataURL(file);
    }
    function createImageElement(src, x, y) {
      const wrapper = document.createElement("div");
      wrapper.classList.add("image-wrapper");
      wrapper.style.left = x + "px";
      wrapper.style.top = y + "px";
      wrapper.style.zIndex = imageZ++;
      const img = document.createElement("img");
      img.src = src;
      img.classList.add("workspace-image");
      img.style.width = "200px";
      img.style.height = "auto";
      img.setAttribute("draggable", "false");
      wrapper.appendChild(img);
      canvas.appendChild(wrapper);
      makeElementDraggable(wrapper);
      addResizeHandles(wrapper, img);
    }
    function addResizeHandles(wrapper, img) {
      ["top-left", "top-right", "bottom-left", "bottom-right"].forEach(pos => {
        const handle = document.createElement("div");
        handle.classList.add("resize-handle", pos);
        wrapper.appendChild(handle);
        makeElementResizable(wrapper, img, handle, pos);
      });
    }
    function makeElementResizable(wrapper, img, handle, position) {
      handle.addEventListener("mousedown", function(event) {
        event.stopPropagation();
        let startX = event.clientX;
        let startY = event.clientY;
        let startWidth = img.offsetWidth;
        let startHeight = img.offsetHeight;
        let startLeft = wrapper.offsetLeft;
        let startTop = wrapper.offsetTop;
        function onMouseMove(e) {
          let deltaX = e.clientX - startX;
          let deltaY = e.clientY - startY;
          if (position.includes("right")) { img.style.width = Math.max(50, startWidth + deltaX) + "px"; }
          if (position.includes("left")) {
            img.style.width = Math.max(50, startWidth - deltaX) + "px";
            wrapper.style.left = Math.max(0, startLeft + deltaX) + "px";
          }
          if (position.includes("bottom")) { img.style.height = Math.max(50, startHeight + deltaY) + "px"; }
          if (position.includes("top")) {
            img.style.height = Math.max(50, startHeight - deltaY) + "px";
            wrapper.style.top = Math.max(0, startTop + deltaY) + "px";
          }
        }
        function onMouseUp() {
          document.removeEventListener("mousemove", onMouseMove);
          document.removeEventListener("mouseup", onMouseUp);
        }
        document.addEventListener("mousemove", onMouseMove);
        document.addEventListener("mouseup", onMouseUp);
      });
    }
    function createTextElement(x, y, content = "") {
      const textElement = document.createElement("div");
      textElement.classList.add("text-entity");
      textElement.style.left = x + "px";
      textElement.style.top = y + "px";
      textElement.style.zIndex = textZ++;
      textElement.style.opacity = "1";
      textElement.textContent = content;
      textElement.setAttribute("contenteditable", "true");
      textElement.addEventListener("focus", function() {
        currentTextEntity = textElement;
        toolbarFontSelector.value = window.getComputedStyle(textElement).fontFamily.replace(/"/g, "");
        toolbarFontSize.value = window.getComputedStyle(textElement).fontSize;
        toolbarFontColor.value = rgbToHex(window.getComputedStyle(textElement).color);
        toolbarBgColor.value = rgbToHex(window.getComputedStyle(textElement).backgroundColor);
        toolbarTextOpacity.value = parseInt(parseFloat(window.getComputedStyle(textElement).opacity) * 100);
      });
      textElement.addEventListener("blur", function() {
        if (textElement.textContent.trim() === "") { textElement.remove(); }
      });
      makeElementDraggable(textElement);
      canvas.appendChild(textElement);
      textElement.focus();
    }
    function rgbToHex(rgb) {
      const result = /^rgba?\((\d+),\s*(\d+),\s*(\d+)/i.exec(rgb);
      return result ? "#" + ((1 << 24) + (parseInt(result[1]) << 16) + (parseInt(result[2]) << 8) + parseInt(result[3])).toString(16).slice(1) : rgb;
    }
    function makeElementDraggable(element) {
      element.setAttribute("draggable", "false");
      element.addEventListener("dragstart", function(e) { e.preventDefault(); });
      element.addEventListener("mousedown", function(e) {
        e.stopPropagation();
        if (element.classList.contains("text-entity")) {
          element.style.zIndex = textZ++;
          currentTextEntity = element;
        } else if (element.classList.contains("image-wrapper")) {
          element.style.zIndex = imageZ++;
        }
        let startX = e.clientX;
        let startY = e.clientY;
        const rect = element.getBoundingClientRect();
        const canvasRect = canvas.getBoundingClientRect();
        const shiftX = e.clientX - rect.left;
        const shiftY = e.clientY - rect.top;
        let ghost = element.cloneNode(true);
        ghost.style.position = "absolute";
        ghost.style.pointerEvents = "none";
        ghost.style.opacity = "0.7";
        ghost.style.left = element.style.left;
        ghost.style.top = element.style.top;
        ghost.style.cursor = "grabbing";
        canvas.appendChild(ghost);
        function moveAt(pageX, pageY) {
          let newX = pageX - canvasRect.left - shiftX + canvas.scrollLeft;
          let newY = pageY - canvasRect.top - shiftY + canvas.scrollTop;
          ghost.style.left = Math.max(0, newX) + "px";
          ghost.style.top = Math.max(0, newY) + "px";
        }
        function onMouseMove(e) { moveAt(e.pageX, e.pageY); }
        document.addEventListener("mousemove", onMouseMove);
        document.addEventListener("mouseup", function(e) {
          document.removeEventListener("mousemove", onMouseMove);
          element.style.left = ghost.style.left;
          element.style.top = ghost.style.top;
          canvas.removeChild(ghost);
        }, { once: true });
      });
    }
    toolbarFontSelector.addEventListener("change", function() {
      if (currentTextEntity) { currentTextEntity.style.fontFamily = this.value; }
    });
    toolbarFontSize.addEventListener("change", function() {
      if (currentTextEntity) { currentTextEntity.style.fontSize = this.value; }
    });
    toolbarFontColor.addEventListener("change", function() {
      if (currentTextEntity) { currentTextEntity.style.color = this.value; }
    });
    toolbarBgColor.addEventListener("change", function() {
      if (currentTextEntity) { currentTextEntity.style.backgroundColor = this.value; }
    });
    toolbarTextOpacity.addEventListener("input", function() {
      if (currentTextEntity) { currentTextEntity.style.opacity = this.value / 100; }
    });
    markerToggle.addEventListener("click", function() {
      currentTool = currentTool === "marker" ? "select" : "marker";
      markerToggle.classList.toggle("active", currentTool === "marker");
      eraserToggle.classList.remove("active");
      if (currentTool === "marker" || currentTool === "eraser") {
        drawingLayer.style.pointerEvents = "auto";
        drawingLayer.style.zIndex = "500";
      } else {
        drawingLayer.style.pointerEvents = "none";
        drawingLayer.style.zIndex = "-1";
      }
    });
    eraserToggle.addEventListener("click", function() {
      currentTool = currentTool === "eraser" ? "select" : "eraser";
      eraserToggle.classList.toggle("active", currentTool === "eraser");
      markerToggle.classList.remove("active");
      if (currentTool === "marker" || currentTool === "eraser") {
        drawingLayer.style.pointerEvents = "auto";
        drawingLayer.style.zIndex = "500";
      } else {
        drawingLayer.style.pointerEvents = "none";
        drawingLayer.style.zIndex = "-1";
      }
    });
    drawingLayer.addEventListener("mousedown", function(e) {
      if (currentTool === "marker" || currentTool === "eraser") {
        drawing = true;
        const rect = drawingLayer.getBoundingClientRect();
        lastX = e.clientX - rect.left;
        lastY = e.clientY - rect.top;
        ctx.beginPath();
        ctx.moveTo(lastX, lastY);
        if (currentTool === "eraser") {
          ctx.globalCompositeOperation = "destination-out";
          ctx.strokeStyle = "rgba(0,0,0,1)";
          ctx.lineWidth = eraserThicknessInput.value;
        } else {
          ctx.globalCompositeOperation = "source-over";
          ctx.strokeStyle = markerColorInput.value;
          ctx.globalAlpha = markerOpacityInput.value / 100;
          ctx.lineWidth = markerThicknessInput.value;
        }
        ctx.lineCap = "round";
      }
    });
    drawingLayer.addEventListener("mousemove", function(e) {
      if (!drawing) return;
      const rect = drawingLayer.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      ctx.lineTo(x, y);
      ctx.stroke();
    });
    drawingLayer.addEventListener("mouseup", function(e) {
      if (drawing) { drawing = false; ctx.closePath(); ctx.globalAlpha = 1; }
    });
    drawingLayer.addEventListener("mouseout", function(e) {
      if (drawing) { drawing = false; ctx.closePath(); ctx.globalAlpha = 1; }
    });
  </script>
</body>
</html>
